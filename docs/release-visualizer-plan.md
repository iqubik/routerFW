# План визуализатора развития проекта по CHANGELOG

## Как устроена текущая «змейка» (snake.yml)

- **Workflow:** `.github/workflows/snake.yml` по расписанию (cron) или вручную (`workflow_dispatch`).
- **Действие:** `Platane/snk@v3` — берёт **график контрибуций GitHub** пользователя `github.repository_owner`, генерирует два SVG (light/dark).
- **Выход:** файлы в `dist/`: `github-contribution-grid-snake.svg`, `github-contribution-grid-snake-dark.svg`.
- **Публикация:** `crazy-max/ghaction-github-pages@v3.1.0` пушит папку `dist` в ветку `output`.
- **Встраивание в README:** через `<picture>` с двумя `<source>` (dark/light) и `<img>`, URL:  
  `https://raw.githubusercontent.com/iqubik/routerFW/output/<имя>.svg`.

Итого: данные (контрибуции) не в репозитории — их даёт API GitHub; наш код только вызывает action и публикует артефакт. В нашем случае **источник данных — локальный CHANGELOG.md**, значит визуализатор должен **читать файл и генерировать SVG кодом** (без внешнего action типа snk).

---

## Структура CHANGELOG.md (что парсить без ИИ)

Файл разбит на блоки по маркеру:

```text
## ========== TAG: X.Y [=]* ==========
```

В каждом блоке:

1. **Заголовок (до первой строки `--`):** пары `key:\tvalue`:
   - `tag` — версия (надёжно).
   - `published` — дата публикации ISO (надёжно).
   - `created` — дата создания.
   - `title` — заголовок релиза.
   - `url` — ссылка на Release.

2. **Тело (после `--`):** произвольный Markdown (описание изменений).

Парсер может **не загружать весь файл в память**: искать по регулярному выражению границы блоков и читать только строки заголовка (до `--`). Тело можно обрабатывать потоково или пропускать для минимальной визуализации (только тег + дата).

---

## Упрощения и метрики без ИИ (что извлекать кодом)

Достаточно для достоверной визуализации:

| Данные | Источник | Надёжность |
|--------|----------|------------|
| Версия (tag) | строка `tag:\t...` | 100% |
| Дата релиза | строка `published:\t...` (ISO 8601) | 100% |
| Заголовок | строка `title:\t...` | 100% |
| URL | строка `url:\t...` | 100% |
| Количество пунктов списка | число вхождений `\n*` или `\n-` в теле блока | эвристика |
| Ссылка «Full Changelog» | regex `compare/([^\s...]+)\.\.\.([^\s]+)` в теле | эвристика |
| Длина тела | символы/строки между `--` и следующим `## ========== TAG:` | стабильно |

Дополнительно (по желанию):

- Подсчёт ключевых слов в теле: `Fix`, `Исправлен`, `Feature`, `Добавлен`, `Refactor`, `Новое` — для категории релиза (fix/feature/refactor).
- Нормализация версии для сортировки: разбить `X.Y` на числа, учесть суффиксы вроде `_hotfix` (считать как одна точка на временной шкале).

Никакого семантического «понимания» текста не требуется — только регулярные выражения и подсчёты.

---

## Схема данных для визуализации (результат парсинга)

Минимальная структура на один релиз:

```json
{
  "tag": "4.43",
  "published": "2026-02-18T21:29:46Z",
  "title": "4.43 lang refactor",
  "url": "https://github.com/.../releases/tag/4.43",
  "bullet_count": 12,
  "body_length": 2500
}
```

Массив таких объектов, отсортированный по `published`, — вход для построения графика. Опционально: поля `prev_tag` / `next_tag` из ссылок «Full Changelog» для отображения цепочки версий.

---

## Варианты визуализации (SVG)

1. **Временная шкала (timeline)**  
   Ось X — время (published), ось Y — метка версии (tag). Точки или вертикальные отрезки; при наведении (title) — tooltip. Можно добавить высоту столбика по `bullet_count` или `body_length` как «объём изменений».

2. **Линия прогресса (progress path)**  
   Версии по порядку слева направо (1.0 → 2.0 → … → 4.43), подписи под точками, даты под ними или при наведении. Линия или ломаная соединяет точки. Подходит для «древа» в смысле последовательности версий.

3. **SVG с анимацией**  
   Тот же timeline или progress path, но точки/линия появляются по очереди (CSS `animation` или SMIL `animate` по датам). Даёт эффект «развития во времени» без изменения данных.

Рекомендация: сначала реализовать **статичный timeline** (тег + дата + опционально «объём»), затем при необходимости добавить вариант с анимацией и/или progress path.

---

## Где держать код и артефакты

- **Скрипт парсинга + генерации SVG:**  
  `system/changelog-to-svg.ps1` (или `system/release-visualizer.ps1`) — по аналогии с `system/get-git.ps1`: читает `CHANGELOG.md` из корня репозитория, пишет:
  - в корень или в `docs/`: например `release-timeline.svg` (и при желании `release-timeline-dark.svg` для тёмной темы).
- **Вход:** путь к `CHANGELOG.md` (по умолчанию корень проекта).
- **Выход:** один или несколько SVG-файлов + опционально JSON с массивом релизов (для отладки или других инструментов).

После появления скрипта можно добавить **GitHub Action** (отдельный workflow или шаг в существующем), который:
- при push в main или при релизе (или по расписанию) запускает `get-git.ps1` (обновление CHANGELOG), затем `changelog-to-svg.ps1`;
- коммитит сгенерированные SVG в репозиторий (например `docs/`) или публикует в ветку `output` по аналогии со змейкой — тогда в README встраивается так же, через URL на raw SVG.

---

## Встраивание в README (как у змейки)

После генерации SVG (например в `docs/release-timeline.svg` или в `output/`):

```html
<picture>
  <source media="(prefers-color-scheme: dark)" srcset=".../release-timeline-dark.svg">
  <source media="(prefers-color-scheme: light)" srcset=".../release-timeline.svg">
  <img alt="Release timeline" src=".../release-timeline.svg">
</picture>
```

Если делается только светлая тема — достаточно одного `<img>`.

---

## Этапы реализации

1. **Парсер CHANGELOG** (в скрипте): разбиение по `## ========== TAG:`, извлечение из каждого блока полей `tag`, `published`, `title`, `url` до `--`; опционально по телу — `bullet_count`, `body_length`, ссылки compare.
2. **Нормализация дат и сортировка** по `published`.
3. **Генерация SVG:** расчёт позиций по оси времени, подписи тегов, ссылки на `url` в `<a xlink:href="...">`. Опционально: высота/ширина столбика по активности.
4. **Интеграция:** вызов скрипта из корня репо; при необходимости — workflow для автообновления и коммита/публикации SVG.
5. **Документация:** в README или в `docs/` кратко описать, что график строится по CHANGELOG и как перегенерировать (локально и через CI).

Такой визуализатор будет полностью основан на данных из релизов, без чтения и «осмысления» всего текста человеком или ИИ — только структурированный разбор и однозначные метрики.
