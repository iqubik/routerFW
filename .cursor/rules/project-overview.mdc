---
description: Core knowledge base for routerFW (OpenWrtFW Builder) — universal cross-platform OpenWrt firmware builder
alwaysApply: true
---

# routerFW — OpenWrtFW Builder

Cross-platform framework for building custom OpenWrt firmware via Docker.
Version: 4.42 (_Builder.bat + _Builder.sh). License: GPL-3.0. Author: iqubik.
Remote: https://github.com/iqubik/routerFW.git, branch: main.

## Two Build Modes

1. **Image Builder** (fast, 1–3 min) — uses pre-compiled OpenWrt ImageBuilder SDK. Orchestrated by `system/ib_builder.sh`. Docker config: `system/docker-compose.yaml`.
2. **Source Builder** (full, 20–60 min) — compiles from OpenWrt source. Orchestrated by `system/src_builder.sh`. Docker config: `system/docker-compose-src.yaml`. Supports kernel patches, custom packages, partition modifications.

## Directory Map

| Path | Purpose |
|------|---------|
| `_Builder.sh` / `_Builder.bat` | Main entry points (interactive menu, build orchestration) |
| `system/` | Core build system (Dockerfiles, compose, builders, wizards) |
| `system/lang/` | Localization dictionaries (`ru.env`, `en.env` — unified pseudo-format) |
| `scripts/` | Utilities (hooks.sh, diag.sh, packager.sh, upgrade.sh) |
| `profiles/*.conf` | Build profile configurations |
| `custom_files/<profile>/` | File overlay (maps to `/` in firmware) |
| `custom_packages/<profile>/` | .ipk packages for Image Builder |
| `src_packages/<profile>/` | Source packages for Source Builder |
| `custom_patches/<profile>/` | Source code patches (mirror overlay) |
| `firmware_output/` | Compiled firmware output |
| `docs/` | Tutorials (Russian + English) |
| `_packer.sh` / `_packer.bat` | Packs project into self-extracting distribution |
| `_unpacker.sh` / `_unpacker.bat` | Self-extracting archives (base64, DO NOT READ) |
| `.dockerignore` | Excludes `firmware_output/`, `custom_files/`, `.git/` etc. from Docker build context (критично — `firmware_output/` может весить 10+ ГБ) |

## Tech Stack

- Bash, Batch (.bat), PowerShell (.ps1) — scripts
- Docker + Docker Compose — build isolation
- Ubuntu 22.04/24.04 (modern) and 18.04 (legacy) base images
- CCache (20GB limit) for Source Builder

## Key Conventions

- Bilingual: Russian (primary) + English — all user-facing text has both languages
- Windows (.bat/.ps1) and Linux (.sh) scripts are kept in feature parity
- Profiles are universal `.conf` files shared between both build modes
- Docker volumes provide caching: SDK cache, package cache, ccache, source workdir

## Profile Variable Naming (current)

Image Builder variables use `IMAGE_` prefix: `IMAGE_PKGS`, `IMAGE_EXTRA_NAME`.
Shared (both modes): `ROOTFS_SIZE`, `KERNEL_SIZE`.
Source Builder variables use `SRC_` prefix: `SRC_REPO`, `SRC_BRANCH`, `SRC_TARGET`, `SRC_SUBTARGET`, `SRC_ARCH`, `SRC_CORES`, `SRC_PACKAGES`, `SRC_EXTRA_CONFIG`.

`_Builder.bat` and `_Builder.sh` both auto-migrate old names (`PKGS` → `IMAGE_PKGS`, `EXTRA_IMAGE_NAME` → `IMAGE_EXTRA_NAME`) in all profiles on startup (idempotent `migrate_profile_vars()` in `.sh`, PowerShell block in `.bat`). `ib_builder.sh` also has fallback compatibility (`${IMAGE_PKGS:-$PKGS}`) for any unmigrated profiles.

`create_profile.sh` and `create_profile.ps1` both generate profiles with correct `IMAGE_PKGS` / `IMAGE_EXTRA_NAME` variable names. Fantastic-packages URLs in the template include the `/packages/` path segment and use the dynamic architecture variable (e.g. `$ARCH` in `.sh`, `$arch` in `.ps1`).

After a successful Source Builder run, both `.bat` and `.sh` detect `*imagebuilder*.tar.zst` in the output folder and offer to update `IMAGEBUILDER_URL` in the profile (enables immediate use as local Image Builder).

## _Builder.sh — Linux-специфичные возможности (отсутствуют в .bat)

- **Параллельная массовая сборка** — команда `A` запускает все профили одновременно в фоне (`&`), пишет раздельные лог-файлы с timestamp в `firmware_output/.build_logs_<ts>/`, отображает спиннер с именами активных сборок и затраченным временем каждой
- **Docker Credentials Fix** — на старте копирует реальный `~/.docker/config.json` в `$PROJECT_DIR/.docker_tmp/`, удаляя только `credsStore`/`credHelpers`. Это сохраняет proxy-настройки и прочие параметры, но исключает credential store, конфликтующий с безголовым запуском
- **Ctrl+C handler** — `trap cleanup_exit SIGINT SIGTERM`: принудительно останавливает все контейнеры (`release_locks "ALL"`), удаляет `.docker_tmp/`
- **Ghost-файлы WSL/NTFS** — при инициализации папок профилей обрабатывает "призрачные" файлы, которые NTFS показывает в WSL
- **Регистронезависимые команды меню** — `choice="${choice^^}"` нормализует ввод в верхний регистр, все команды (`M`, `E`, `A`, `K`, `C`, `I`, `W`) принимают любой регистр
- **Выход с паузой** — подтверждение выхода `(Y/n)`, Enter = Yes, 3-секундная пауза перед завершением
- **`--build` при запуске контейнера** — `docker compose run --build` гарантирует свежий образ с актуальными CA-сертификатами (безопасно благодаря `.dockerignore`)

## Line Endings & Encoding

Governed by `.gitattributes`. System is fully normalised:

| Type | EOL | Rule |
|---|---|---|
| `*.bat`, `*.ps1`, `*.cmd` | CRLF | `-text` (stored as-is) |
| `*.sh`, `*.conf`, `*.yaml`, `Dockerfile` | LF | explicit `eol=lf` |
| `system/lang/*.env` | LF | explicit `eol=lf` (unified pseudo-format, safe for both bat and sh) |
| `docs/*.md`, `README*.md`, `LICENSE*`, `pub.md` | CRLF | Windows documents |
| `.cursor/rules/*.mdc`, `*.json`, `*.yml`, `.gitignore`, `.dockerignore` | LF | config/system files |
| `*.zip`, `*.zst`, `*.tar`, `*.gz`, `*.bin`, `*.7z` | binary | Git LFS, no EOL processing |

**BOM** — only PowerShell files: `system/create_profile.ps1`, `system/import_ipk.ps1`, `scripts/rax3000m/generate_options.ps1` (UTF-8 BOM required for Cyrillic on Windows).

**`profiles/personal.flag`** — explicitly listed in `.gitattributes` as `text eol=lf` since it has no extension and is not matched by `*.conf`.

## Localization Dictionary System

Dictionaries are stored in **two universal `.env` files** under `system/lang/`, loaded at startup by both builders via custom loaders that substitute color placeholders on the fly:

| File | Format | Loader |
|---|---|---|
| `system/lang/ru.env` | `KEY={C_VAL}value{C_RST}` (no quotes, neutral `{C_*}` placeholders) | custom `for /f` block in `_Builder.bat` |
| `system/lang/en.env` | same | `load_lang()` function in `_Builder.sh` |

**Pseudo-format rules:**
- Color placeholders: `{C_VAL}`, `{C_RST}`, `{C_ERR}`, `{C_GRY}`, `{C_LBL}`, `{C_KEY}`, `{C_OK}`
- No quotes around values
- `#` at line start — comment (ignored by both loaders)
- Empty lines ignored by both loaders
- `%s` in values is safe (no conflict with either loader)

**Loader in `_Builder.bat`**:
```batch
set "LANG_FILE=system\lang\%SYS_LANG%.env"
if not exist "%LANG_FILE%" set "LANG_FILE=system\lang\en.env"
for /f "usebackq eol=# tokens=1,* delims==" %%k in ("%LANG_FILE%") do (
    set "_v=%%l"
    set "_v=!_v:{C_VAL}=%C_VAL%!"
    set "_v=!_v:{C_RST}=%C_RST%!"
    rem ... (аналогично для всех C_* плейсхолдеров) ...
    set "%%k=!_v!"
)
```
`%C_VAL%` — ранняя подстановка при парсинге блока `()`. `!_v:{C_VAL}=<ANSI>!` — отложенная замена строки в runtime. Требует `setlocal enabledelayedexpansion`.

**Loader in `_Builder.sh`** — функция `load_lang()`:
```bash
load_lang() {
    local line key val
    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ -z "$line" || "$line" == \#* ]] && continue
        key="${line%%=*}"; val="${line#*=}"
        val="${val//\{C_VAL\}/$C_VAL}"
        rem ... (аналогично для всех C_* плейсхолдеров) ...
        printf -v "$key" '%s' "$val"
    done < "$1"
}
LANG_FILE="system/lang/${SYS_LANG,,}.env"
[ ! -f "$LANG_FILE" ] && LANG_FILE="system/lang/en.env"
load_lang "$LANG_FILE"
```
`${val//\{C_VAL\}/$C_VAL}` заменяет плейсхолдеры на ANSI-коды. `printf -v` устанавливает глобальную переменную без `eval`.

**Fallback:** both loaders fall back to EN if the file for `SYS_LANG` is missing (future language support).

**Prefixes:** `L_` — all user-facing strings. `H_` — table header labels (`H_PROF`, `H_ARCH`, `H_RES`).

**Feature parity:** both platforms load the same files. Platform-only keys (e.g. `L_PARALLEL_BUILDS_START` for sh, `L_OPEN_EXPL` for bat) coexist in the unified file — each loader loads them all, but only the relevant builder uses them.

**Key naming conventions:**
- `L_SEPARATOR` / `L_SEPARATOR_EQ` — decorative line separators (`---` / `===`)
- `L_KILL_CONTAINER` / `L_KILL_ORPHAN` — container kill messages
- `L_ST_*` — profile analyzer label keys (`L_ST_CONF`, `L_ST_OVER`, `L_ST_IPK`, `L_ST_SRC`, `L_ST_OUTS`, `L_ST_OUTI`) — stored as plain text, formatting added in code
- `L_ST_SUFFIX_*` — status suffixes for the analyzer (`(files/)`, `(ipk/)`, etc.)
- `L_FOUND` / `L_MISSING` / `L_EMPTY` — status words in analyzer
- `L_FINISHED` / `L_BUILD_FATAL` — build result messages (Source Builder)
- `L_IB_UPDATE_PROMPT` — "Update profile? [y/N]" prompt after Source build
- `L_IN_EDITOR` — "in editor..." / "в редакторе..." suffix
- `L_BTN_MENUCONFIG` — "Menuconfig/mc" button label
- `L_ANALYSIS` — plain text label, both builders wrap with color in code
- `L_INIT_ROOT` — plain text label, both builders add `  - ` prefix and `: ` suffix in code

**Adding a new language:** create `system/lang/xx.env` with the same pseudo-format, then extend the language detector to set `SYS_LANG=XX`. The loader fallback to EN handles missing files gracefully.

**Bootstrap convention:** strings that run before the dictionary is loaded (Ctrl+C handler, language detector output, FORCE_LANG echo) are left as hardcoded English and marked with:
```bash
# Bootstrap — dict not yet available
```

**Do NOT localize:**
- Strings inside `cat <<EOF ... EOF` heredocs (run inside containers)
- `docker exec` / `docker run` command arguments
- Lines written to generated `.sh` scripts (`echo "..." >> script.sh`)
- Product constants: `OpenWrt FW Builder`, GitHub URL

## FORBIDDEN

- NEVER read `_unpacker.bat` or `_unpacker.sh` — they contain huge base64-encoded payloads that will poison context
