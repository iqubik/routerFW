# file: system/docker-compose-src.yaml v2.31
services:
  builder-src-openwrt:
    build:
      context: ..
      dockerfile: system/src.dockerfile
    user: "root"
    environment:
      - CONF_FILE=${SELECTED_CONF}
      - CCACHE_DIR=/ccache
    volumes:
      - src-workdir:/home/build/openwrt
      - src-dl-cache:/home/build/openwrt/dl
      - src-ccache:/ccache
      - ../profiles:/profiles
      - ../src_packages:/input_packages
      - ../${HOST_FILES_DIR}:/overlay_files
      - ../${HOST_OUTPUT_DIR}:/output
      - ./openssl.cnf:/openssl.cnf

    command: &src_build_script |
      /bin/bash -c "
      set -e
      echo '[INIT] Checking volume permissions...'
      
      # 1. Исправление прав для рабочей папки
      if [ \"$$(stat -c '%U' /home/build/openwrt)\" != \"build\" ]; then
          echo \"[INIT] First run detected: Fixing ownership of workdir...\"
          chown -R build:build /home/build/openwrt
      fi

      # 2. FIX: Исправление прав для CCACHE (Иначе компилятор не сможет писать кэш и упадет)
      if [ -d \"/ccache\" ] && [ \"$$(stat -c '%U' /ccache)\" != \"build\" ]; then
          echo \"[INIT] Fixing ownership of /ccache volume...\"
          chown -R build:build /ccache
      fi

      # Создаем скрипт сборки внутри контейнера
      cat << 'EOF' > /tmp/build_script.sh      
      set -e
      export HOME=/home/build
      PROFILE_ID=$$(basename \"$$CONF_FILE\" .conf)

      # === 0. Setup Environment ===
      if [ ! -f \"/profiles/$$CONF_FILE\" ]; then
        echo \"FATAL: Profile /profiles/$$CONF_FILE not found!\"
        exit 1
      fi
      
      # === КОНВЕРТАЦИЯ CRLF -> LF И УДАЛЕНИЕ BOM ===
      echo \"[INIT] Normalizing config...\"
      cat \"/profiles/$$CONF_FILE\" | sed '1s/^\\xEF\\xBB\\xBF//' | tr -d '\\r' > /tmp/clean_config.env
      source /tmp/clean_config.env

      # ВАЖНО: Экспортируем переменные, чтобы hooks.sh их видел
      export SRC_REPO SRC_BRANCH SRC_TARGET SRC_SUBTARGET SRC_DEVICE PROFILE_NAME SRC_PACKAGES

      if [ -z \"$$SRC_REPO\" ]; then
         echo \"[ERROR] SRC_REPO is empty! Config was not parsed correctly.\"
         exit 1
      fi
      
      echo \"==================================================\"
      echo \"   OpenWrt SOURCE Builder for $$PROFILE_NAME\"
      echo \"==================================================\"
      
      START_TIME=$$(date +%s)
      TIMESTAMP=$$(TZ='UTC-3' date +%d%m%y-%H%M%S)
      
      # === 1. GIT SETUP ===
      if [ ! -d \".git\" ]; then
          echo \"[GIT] Initializing repo in non-empty dir...\"
          # Убираем надоедливое предупреждение о ветке master/main
          git config --global init.defaultBranch master
          
          # --- FIX FOR GNUTLS / GITHUB ---
          echo \"[GIT] Applying connection fixes...\"
          # Увеличиваем буфер для скачивания больших объектов
          git config --global http.postBuffer 524288000
          # Принудительно используем HTTP/1.1 (GnuTLS часто падает на HTTP/2)
          git config --global http.version HTTP/1.1
          # Можно попробовать принудительно TLS 1.2, если 1.3 сбоит
          git config --global http.sslVersion tlsv1.2
          # -------------------------------

          git init
          git remote add origin \"$$SRC_REPO\"
      fi
      
      echo \"[GIT] Fetching $$SRC_BRANCH...\"
      git fetch origin \"$$SRC_BRANCH\"
      
      echo \"[GIT] Checkout/Reset to $$SRC_BRANCH...\"      
      git config --global advice.detachedHead false
      git checkout -f \"FETCH_HEAD\"
      git reset --hard \"FETCH_HEAD\"

      # === SMART FEEDS MIRROR ===
      if [ -f feeds.conf.default ]; then
          if grep -q \"immortalwrt\" feeds.conf.default; then
              echo \"[INFO] ImmortalWrt detected. Keeping original feeds for fork compatibility.\"
          else
              echo \"[FIX] Vanilla OpenWrt detected. Switching to GitHub mirrors for speed...\"
              sed -i 's|https://git.openwrt.org/feed/|https://github.com/openwrt/|g' feeds.conf.default
              sed -i 's|https://git.openwrt.org/project/|https://github.com/openwrt/|g' feeds.conf.default
          fi
      fi

      # === 2. FEEDS ===
      echo \"[FEEDS] Updating and Installing feeds...\"
      ./scripts/feeds update -a
      ./scripts/feeds install -a

      # === BUILD HOOKS (PRE-BUILD SCRIPT) ===
      TARGET_MK=\"include/kernel-defaults.mk\"
      BACKUP_MK=\"include/kernel-defaults.mk.bak\"
      VERMAGIC_MARKER=\".last_vermagic\"

      # Цвета для вывода (экранированные)
      GREEN='\\033[0;32m'
      RED='\\033[0;31m'
      YELLOW='\\033[1;33m'
      CYAN='\\033[0;36m'
      NC='\\033[0m'
      
      echo \"[HOOKS] Checking for custom hooks in /overlay_files/hooks.sh...\"

      if [ -f \"/overlay_files/hooks.sh\" ]; then
          echo \"[HOOKS] Found hooks.sh! Sanitizing (CRLF -> LF) and executing...\"

          tr -d '\\r' < \"/overlay_files/hooks.sh\" > /tmp/hooks.sh
          chmod +x /tmp/hooks.sh
          /bin/bash /tmp/hooks.sh || {
              echo -e \"$${RED}[ERROR] hooks.sh failed!$${NC}\"
              exit 1
          }

          echo -e \"$${GREEN}[HOOKS] Custom modifications applied successfully.$${NC}\"
      else
          echo -e \"$${CYAN}[HOOKS] hooks.sh not found. Checking system state...$${NC}\"
          echo \"\"
          echo \"[DEBUG] ========== STATE CHECK BEGIN ==========\"
          echo \"[DEBUG] TARGET_MK = $$TARGET_MK\"
          echo \"[DEBUG] BACKUP_MK = $$BACKUP_MK\"
          echo \"[DEBUG] VERMAGIC_MARKER = $$VERMAGIC_MARKER\"
          echo \"\"

          # Переменные состояния
          NEEDS_ROLLBACK=false
          IS_PATCHED=false
          
          # Проверка 1: Makefile патчен? (Умная проверка для старших и младших версий)
          echo \"[DEBUG] Check 1: Is Makefile patched?\"
          if [ -f \"$$TARGET_MK\" ]; then
              # Ищем признаки нашего вмешательства (echo + хэш)
              if grep -Eq 'echo [0-9a-f]{32}' \"$$TARGET_MK\" 2>/dev/null; then
                  echo -e \"[DEBUG]   - Status: $${RED}PATCHED$${NC} (Hardcoded hash detected)\"
                  IS_PATCHED=true
                  NEEDS_ROLLBACK=true
              else
                  # Проверяем, выглядит ли файл "чистым" (поддержка MKHASH, mkhash, md5sum)
                  if grep -E 'MKHASH|mkhash|md5sum' \"$$TARGET_MK\" >/dev/null 2>&1; then
                      echo -e \"[DEBUG]   - Status: $${GREEN}CLEAN$${NC} (Standard hashing tool found)\"
                  else
                      echo -e \"[DEBUG]   - Status: $${YELLOW}UNKNOWN$${NC} (Syntax check inconclusive, safer to rollback)\"
                      # Если синтаксис непонятен, считаем, что лучше откатить (если есть бэкап)
                      if [ -f \"$$BACKUP_MK\" ]; then NEEDS_ROLLBACK=true; fi
                  fi
              fi
          else
              echo \"[DEBUG]   - File exists: NO\"
          fi
          
          # Проверка 2: Маркер существует?
          echo \"[DEBUG] Check 2: Does vermagic marker exist?\"
          if [ -f \"$$VERMAGIC_MARKER\" ]; then
              MARKER_CONTENT=\$$(cat \"$$VERMAGIC_MARKER\")
              echo -e \"[DEBUG]   - Marker exists: $${RED}YES$${NC} (content: $$MARKER_CONTENT)\"
              NEEDS_ROLLBACK=true
          else
              echo -e \"[DEBUG]   - Marker exists: $${GREEN}NO$${NC}\"
          fi
          
          # Проверка 3: Бэкап существует?
          echo \"[DEBUG] Check 3: Does backup exist?\"
          if [ -f \"$$BACKUP_MK\" ]; then
              echo -e \"[DEBUG]   - Backup exists: $${RED}YES$${NC}\"
              NEEDS_ROLLBACK=true
          else
              echo -e \"[DEBUG]   - Backup exists: $${GREEN}NO$${NC}\"
          fi
          
          echo \"[DEBUG] NEEDS_ROLLBACK = $$NEEDS_ROLLBACK\"
          echo \"[DEBUG] ========== STATE CHECK END ==========\"
          echo \"\"

          if [ \"$$NEEDS_ROLLBACK\" = \"false\" ]; then
              echo -e \"$${GREEN}[HOOKS] ✓ System already in clean state. Nothing to do.$${NC}\"
          else
              echo -e \"$${YELLOW}[HOOKS] Dirty state detected. Performing rollback and cache cleanup...$${NC}\"
              echo \"\"

              # 1. Восстановление оригинального Makefile из бэкапа
              if [ -f \"$$BACKUP_MK\" ]; then
                  echo \"[DEBUG] Backup file found, processing restoration...\"
                  
                  # Если файл был патчен или мы решили откатить
                  echo \"[HOOKS] Restoring $$TARGET_MK from backup...\"
                  cp -f \"$$BACKUP_MK\" \"$$TARGET_MK\"
                  
                  # Универсальная проверка восстановления (Smart Check)
                  if grep -E 'MKHASH|mkhash|md5sum' \"$$TARGET_MK\" >/dev/null 2>&1; then
                      echo -e \"$${GREEN}[HOOKS] ✓ Makefile restored: dynamic vermagic logic present$${NC}\"
                  else
                      # Если после восстановления всё ещё нет стандартных строк (очень старая версия или поврежденный бэкап)
                      echo -e \"$${YELLOW}[HOOKS] ! Makefile restored, but standard tools (MKHASH/mkhash) not explicitly found.$${NC}\"
                      echo \"[HOOKS] Assuming correct legacy state from backup.\"
                  fi
                  
                  # Удаляем бэкап
                  rm -f \"$$BACKUP_MK\"
                  if [ ! -f \"$$BACKUP_MK\" ]; then
                      echo \"[HOOKS] ✓ Backup file removed\"
                  fi
                  
              elif [ \"$$IS_PATCHED\" = \"true\" ]; then
                  echo \"[DEBUG] No backup found for patched file! Attempting git restore...\"
                  git checkout -- \"$$TARGET_MK\" 2>/dev/null || true
                  
                  if grep -E 'MKHASH|mkhash|md5sum' \"$$TARGET_MK\" >/dev/null 2>&1; then
                      echo -e \"$${GREEN}[HOOKS] ✓ Git restore successful$${NC}\"
                  fi
              fi

              # 2. Удаление маркера vermagic
              if [ -f \"$$VERMAGIC_MARKER\" ]; then
                  rm -f \"$$VERMAGIC_MARKER\"
                  echo -e \"$${YELLOW}[HOOKS] ✓ Marker removed: next build will compute fresh hash$${NC}\"
              fi

              # 3. Глубокая очистка кэша (Deep Clean как в hooks.sh)
              echo \"[HOOKS] Cleaning kernel cache (Deep Clean)...\"
              make target/linux/clean > /dev/null 2>&1 || true
              
              # Удаление временных конфигов (Критично для 19.07/21.02)
              rm -rf tmp/.packageinfo tmp/.targetinfo tmp/.config-target.in 2>/dev/null
              
              # Удаление директорий ядра
              find build_dir/target-* -maxdepth 1 -type d -name \"linux-*\" -exec rm -rf {} + 2>/dev/null || true
              
              # Удаление штампов установки (чтобы форсировать пересчет)
              rm -rf staging_dir/target-*/pkginfo/kernel.default.install 2>/dev/null
              
              echo -e \"$${GREEN}[HOOKS] ✓ Kernel cache cleaned$${NC}\"

              # 4. Сброс CCACHE
              if [ -d \"/ccache\" ]; then
                  echo \"[HOOKS] Resetting build ccache...\"
                  rm -rf /ccache/*
                  echo -e \"$${GREEN}[HOOKS] ✓ CCACHE reset$${NC}\"
              fi

              echo \"\"
              echo \"============================================================\"
              echo \"=== ROLLBACK COMPLETE ===\"
              echo \"=== System restored to original OpenWrt build state\"
              echo \"============================================================\"
              echo \"\"
          fi
      fi

      # === CUSTOM SOURCES ===
      # ВАЖНО: Сюда нужно класть ПАПКИ с исходниками (Makefile), а не .ipk файлы!
      if [ -d \"/input_packages\" ] && [ \"$$(ls -A /input_packages)\" ]; then
          echo \"[PKG] Injecting custom sources into package/ directory...\"
          cp -rf /input_packages/* package/
      fi

      # === 3. CONFIGURATION ===
      echo \"[CONFIG] Checking configuration strategy...\"
      rm -f .config

      if [ -f \"/output/manual_config\" ]; then
          echo \"[CONFIG] !!! FOUND manual_config in output folder !!!\"
          echo \"[CONFIG] Applying manual configuration and SKIPPING auto-generation (including SRC_EXTRA_CONFIG).\"
          
          # Копируем ручной конфиг
          cp \"/output/manual_config\" .config
          
          # Всегда включаем CCACHE, так как это настройка среды сборки, а не прошивки
          echo \"CONFIG_CCACHE=y\" >> .config
      else
          echo \"[CONFIG] No manual_config found. Generating standard .config...\"
          
          echo \"CONFIG_CCACHE=y\" >> .config
      
          # Базовая конфигурация Target
          echo \"CONFIG_TARGET_$$SRC_TARGET=y\" >> .config
          echo \"CONFIG_TARGET_$${SRC_TARGET}_$${SRC_SUBTARGET}=y\" >> .config
          echo \"CONFIG_TARGET_$${SRC_TARGET}_$${SRC_SUBTARGET}_DEVICE_$$TARGET_PROFILE=y\" >> .config
          
          # Добавляем пользовательские пакеты из SRC_PACKAGES
          for pkg in $$SRC_PACKAGES; do
              if [[ \"$$pkg\" == -* ]]; then
                  clean_pkg=\"$${pkg#-}\"
                  echo \"# CONFIG_PACKAGE_$$clean_pkg is not set\" >> .config
              else
                  echo \"CONFIG_PACKAGE_$$pkg=y\" >> .config
              fi
          done
          
          # Apply LUCI default (если пользователь не указал его сам)      
          if ! grep -q \"CONFIG_PACKAGE_luci=y\" .config; then
              echo \"CONFIG_PACKAGE_luci=y\" >> .config
          fi
          
          # Sizes
          if [ -n \"$$ROOTFS_SIZE\" ]; then
            echo \"CONFIG_TARGET_ROOTFS_PARTSIZE=$$ROOTFS_SIZE\" >> .config
          fi

          if [ -n \"$$KERNEL_SIZE\" ]; then
            echo \"CONFIG_TARGET_KERNEL_PARTSIZE=$$KERNEL_SIZE\" >> .config
          fi

          # === EXTRA CONFIG (Disable devices / Low level options) ===
          # Этот блок теперь внутри else, поэтому он ИГНОРИРУЕТСЯ при наличии manual_config
          if [ -n \"$$SRC_EXTRA_CONFIG\" ]; then
              echo \"[CONFIG] Applying extra config options (SRC_EXTRA_CONFIG)...\"
              # Обрабатываем переменную как список строк
              for opt in $$SRC_EXTRA_CONFIG; do
                  echo \"$$opt\" >> .config
              done
          fi
      fi

      echo \"[DEBUG] Showing generated SEED .config (active settings only):\"
      echo \"----------------------------------------\"      
      grep -v \"^#\" .config || true
      echo \"----------------------------------------\"      
     
      # make defconfig выровняет зависимости (добавит недостающие пакеты, выбранные в menuconfig)
      make defconfig
      
      # === 4. CUSTOM FILES ===
      if [ -d \"/overlay_files\" ] && [ \"$$(ls -A /overlay_files)\" ]; then
          echo \"[FILES] Copying overlay files...\"
          mkdir -p files
          cp -r /overlay_files/* files/
          rm -f files/hooks.sh
      fi
      
      # === 5. DOWNLOAD ===
      echo \"[DOWNLOAD] Downloading sources to cache...\"
      mkdir -p dl
      make download || (echo \"[ERROR] Download failed! Retrying with logging...\" && make download V=s && exit 1)
      
      # === 6. BUILD ===
      # Определение количества потоков сборки
      SYS_CORES=$$(nproc)
      
      # По умолчанию берем все ядра
      BUILD_JOBS=$$SYS_CORES

      if [ -n \"$$SRC_CORES\" ]; then
          # Если указан режим "safe" или "auto" -> (nproc - 1)
          if [[ \"$$SRC_CORES\" == \"safe\" || \"$$SRC_CORES\" == \"auto\" ]]; then
              echo \"[BUILD] Mode SAFE detected. Reducing core count by 1.\"
              BUILD_JOBS=$$((SYS_CORES - 1))
          # Если указано конкретное число
          elif [[ \"$$SRC_CORES\" =~ ^[0-9]+$$ ]]; then
              BUILD_JOBS=$$SRC_CORES
          fi
      fi

      # Защита от дурака: минимум 1 ядро
      if [ \"$$BUILD_JOBS\" -lt 1 ]; then BUILD_JOBS=1; fi
      
      echo \"[BUILD] Starting compilation...\"
      echo \"        System Cores: $$SYS_CORES\"
      echo \"        Build Jobs:   $$BUILD_JOBS (-j$$BUILD_JOBS)\"

      make -j$$BUILD_JOBS || (echo \"[ERROR] Multicore build failed. Retrying single core V=s...\" && make -j1 V=s)
      
      # === 7. ARTIFACTS ===
      echo \"[SAVE] Saving artifacts...\"
      TARGET_DIR=\"/output/$$TIMESTAMP\"
      mkdir -p \"$$TARGET_DIR\"
      
      # Ищем файлы рекурсивно внутри bin/targets/ARCH, игнорируя папку packages
      find bin/targets/$$SRC_TARGET -type f -not -path \"*/packages/*\" -exec cp {} \"$$TARGET_DIR/\" \\;
      
      # Сохраняем итоговый конфиг для справки
      cp .config \"$$TARGET_DIR/build.config\"
      
      END_TIME=$$(date +%s)
      ELAPSED=$$((END_TIME - START_TIME))
      
      echo \"\"
      echo \"============================================================\"
      echo \"=== Сборка $$PROFILE_NAME завершена за $${ELAPSED}с.\"
      echo \"=== Образы: firmware_output/sourcebuilder/$$PROFILE_ID/$$TIMESTAMP\"
      echo \"============================================================\"
      EOF
      
      chmod +x /tmp/build_script.sh
      chown build:build /tmp/build_script.sh
      
      echo '[EXEC] Switching to user build...'
      sudo -E -u build bash /tmp/build_script.sh
      "

  builder-src-oldwrt:
    build:
      context: ..
      dockerfile: system/src.dockerfile.legacy
    user: "root"
    environment:
      - CONF_FILE=${SELECTED_CONF}
      - CCACHE_DIR=/ccache
    volumes:
      - src-workdir:/home/build/openwrt
      - src-dl-cache:/home/build/openwrt/dl
      - src-ccache:/ccache
      - ../profiles:/profiles
      - ../src_packages:/input_packages
      - ../${HOST_FILES_DIR}:/overlay_files
      - ../${HOST_OUTPUT_DIR}:/output
      - ./openssl.cnf:/openssl.cnf
    command: *src_build_script

volumes:
  src-dl-cache:
  src-workdir:
  src-ccache: