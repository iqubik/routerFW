# file: system/docker-compose-src.yaml v2.5en
services:
  builder-src-openwrt:
    build:
      context: ..
      dockerfile: system/src.dockerfile
    user: "root"
    environment:
      - CONF_FILE=${SELECTED_CONF}
      - CCACHE_DIR=/ccache
    volumes:
      - src-workdir:/home/build/openwrt
      - src-dl-cache:/home/build/openwrt/dl
      - src-ccache:/ccache
      - ../profiles:/profiles      
      - ../${HOST_PKGS_DIR}:/input_packages
      - ../${HOST_FILES_DIR}:/overlay_files
      - ../${HOST_OUTPUT_DIR}:/output
      - ./openssl.cnf:/openssl.cnf

    command: &src_build_script |
      /bin/bash -c "
      set -e
      echo '[INIT] Checking volume permissions...'
      
      # 1. Исправление прав для рабочей папки
      if [ \"$$(stat -c '%U' /home/build/openwrt)\" != \"build\" ]; then
          echo \"[INIT] First run detected: Fixing ownership of workdir...\"
          chown -R build:build /home/build/openwrt
      fi

      # 2. ИСПРАВЛЕНИЕ: Права для CCACHE (необходимо для записи кэша компилятора)
      if [ -d \"/ccache\" ] && [ \"$$(stat -c '%U' /ccache)\" != \"build\" ]; then
          echo \"[INIT] Fixing ownership of /ccache volume...\"
          chown -R build:build /ccache
      fi

      # Создаем внутренний скрипт сборки
      cat << 'EOF' > /tmp/build_script.sh      
      set -e
      export HOME=/home/build
      PROFILE_ID=$$(basename \"$$CONF_FILE\" .conf)

      # === 0. Настройка окружения ===
      if [ ! -f \"/profiles/$$CONF_FILE\" ]; then
        echo \"FATAL: Profile /profiles/$$CONF_FILE not found!\"
        exit 1
      fi
      
      # === КОРРЕКЦИЯ КОНФИГА: CRLF -> LF И УДАЛЕНИЕ BOM ===
      echo \"[INIT] Normalizing config...\"
      cat \"/profiles/$$CONF_FILE\" | sed '1s/^\\xEF\\xBB\\xBF//' | tr -d '\\r' > /tmp/clean_config.env
      source /tmp/clean_config.env

      # Экспорт переменных для видимости в hooks.sh
      export SRC_REPO SRC_BRANCH SRC_TARGET SRC_SUBTARGET SRC_DEVICE PROFILE_NAME SRC_PACKAGES

      if [ -z \"$$SRC_REPO\" ]; then
         echo \"[ERROR] SRC_REPO is empty! Config parse failed.\"
         exit 1
      fi
      
      echo \"==================================================\"
      echo \"   OpenWrt SOURCE Builder for $$PROFILE_NAME\"
      echo \"==================================================\"
      
      START_TIME=$$(date +%s)
      TIMESTAMP=$$(TZ='UTC-3' date +%d%m%y-%H%M%S)
      
      # === 1. НАСТРОЙКА GIT ===
      if [ ! -d \".git\" ]; then
          # Убираем надоедливое предупреждение о ветке master/main
          echo \"[GIT] Initializing repository...\"
          git config --global init.defaultBranch master
          
          # --- ИСПРАВЛЕНИЯ ДЛЯ GNUTLS / GITHUB (Стабильность сети) ---
          echo \"[GIT] Applying network stability fixes...\"
          git config --global http.postBuffer 524288000
          # Принудительно используем HTTP/1.1 (GnuTLS часто падает на HTTP/2)
          git config --global http.version HTTP/1.1
          # Можно попробовать принудительно TLS 1.2, если 1.3 сбоит
          git config --global http.sslVersion tlsv1.2
          # ---------------------------------------------------------

          git init
          git remote add origin \"$$SRC_REPO\"
      fi
      
      echo \"[GIT] Fetching branch: $$SRC_BRANCH...\"
      git fetch origin \"$$SRC_BRANCH\"
      
      echo \"[GIT] Performing checkout and hard reset...\"      
      git config --global advice.detachedHead false
      git checkout -f \"FETCH_HEAD\"
      git reset --hard \"FETCH_HEAD\"

      # === ЗЕРКАЛИРОВАНИЕ ФИДОВ (Ускорение) ===
      if [ -f feeds.conf.default ]; then
          if grep -q \"immortalwrt\" feeds.conf.default; then
              echo \"[INFO] ImmortalWrt detected. Using original feeds.\"
          else
              echo \"[FIX] Vanilla OpenWrt detected. Switching to GitHub mirrors...\"
              sed -i 's|https://git.openwrt.org/feed/|https://github.com/openwrt/|g' feeds.conf.default
              sed -i 's|https://git.openwrt.org/project/|https://github.com/openwrt/|g' feeds.conf.default
          fi
      fi

      # === 2. ОБНОВЛЕНИЕ ФИДОВ ===
      echo \"[FEEDS] Updating and installing feeds...\"
      ./scripts/feeds update -a
      ./scripts/feeds install -a

      # === ХУКИ СБОРКИ (ПРЕДВАРИТЕЛЬНЫЕ СКРИПТЫ) ===
      TARGET_MK=\"include/kernel-defaults.mk\"
      BACKUP_MK=\"include/kernel-defaults.mk.bak\"
      VERMAGIC_MARKER=\".last_vermagic\"

      # Цвета терминала для логов
      GREEN='\\033[0;32m'
      RED='\\033[0;31m'
      YELLOW='\\033[1;33m'
      CYAN='\\033[0;36m'
      NC='\\033[0m'
      
      echo \"[HOOKS] Searching for custom hooks in /overlay_files/hooks.sh...\"

      if [ -f \"/overlay_files/hooks.sh\" ]; then
          echo \"[HOOKS] Found hooks.sh! Normalizing and executing...\"

          tr -d '\\r' < \"/overlay_files/hooks.sh\" > /tmp/hooks.sh
          chmod +x /tmp/hooks.sh
          /bin/bash /tmp/hooks.sh || {
              echo -e \"$${RED}[ERROR] hooks.sh execution failed!$${NC}\"
              exit 1
          }

          echo -e \"$${GREEN}[HOOKS] Custom modifications applied.$${NC}\"
      else
          echo -e \"$${CYAN}[HOOKS] hooks.sh not found. Validating system state...$${NC}\"
          echo \"\"
          echo \"[DEBUG] ========== STATE CHECK BEGIN ==========\"
          echo \"[DEBUG] TARGET_MK = $$TARGET_MK\"
          echo \"[DEBUG] BACKUP_MK = $$BACKUP_MK\"
          echo \"[DEBUG] VERMAGIC_MARKER = $$VERMAGIC_MARKER\"
          echo \"\"

          # Переменные логики отката
          NEEDS_ROLLBACK=false
          IS_PATCHED=false
          
          # Проверка 1: Был ли Makefile изменен? (Поиск жесткого хэша)
          echo \"[DEBUG] Check 1: Is Makefile patched?\"
          if [ -f \"$$TARGET_MK\" ]; then
              if grep -Eq 'echo [0-9a-f]{32}' \"$$TARGET_MK\" 2>/dev/null; then
                  echo -e \"[DEBUG]   - Status: $${RED}PATCHED$${NC} (Hardcoded hash found)\"
                  IS_PATCHED=true
                  NEEDS_ROLLBACK=true
              else
                  if grep -E 'MKHASH|mkhash|md5sum' \"$$TARGET_MK\" >/dev/null 2>&1; then
                      echo -e \"[DEBUG]   - Status: $${GREEN}CLEAN$${NC} (Standard logic found)\"
                  else
                      echo -e \"[DEBUG]   - Status: $${YELLOW}UNKNOWN$${NC} (Inconclusive syntax)\"
                      if [ -f \"$$BACKUP_MK\" ]; then NEEDS_ROLLBACK=true; fi
                  fi
              fi
          else
              echo \"[DEBUG]   - File exists: NO\"
          fi
          
          # Проверка 2: Наличие маркера vermagic
          echo \"[DEBUG] Check 2: Vermagic marker?\"
          if [ -f \"$$VERMAGIC_MARKER\" ]; then
              MARKER_CONTENT=\$$(cat \"$$VERMAGIC_MARKER\")
              echo -e \"[DEBUG]   - Marker exists: $${RED}YES$${NC} (content: $$MARKER_CONTENT)\"
              NEEDS_ROLLBACK=true
          else
              echo -e \"[DEBUG]   - Marker exists: $${GREEN}NO$${NC}\"
          fi
          
          # Проверка 3: Наличие бэкапа
          echo \"[DEBUG] Check 3: Backup exists?\"
          if [ -f \"$$BACKUP_MK\" ]; then
              echo -e \"[DEBUG]   - Backup: $${RED}YES$${NC}\"
              NEEDS_ROLLBACK=true
          else
              echo -e \"[DEBUG]   - Backup exists: $${GREEN}NO$${NC}\"
          fi
          
          echo \"[DEBUG] NEEDS_ROLLBACK = $$NEEDS_ROLLBACK\"
          echo \"[DEBUG] ========== STATE CHECK END ==========\"
          echo \"\"

          if [ \"$$NEEDS_ROLLBACK\" = \"false\" ]; then
              echo -e \"$${GREEN}[HOOKS] System is in clean state.$${NC}\"
          else
              echo -e \"$${YELLOW}[HOOKS] Dirty state detected. Performing rollback...$${NC}\"
              echo \"\"

              # Восстановление оригинального Makefile
              if [ -f \"$$BACKUP_MK\" ]; then
                  echo \"[DEBUG] Backup file found, processing restoration...\"
                  # Если файл был патчен или мы решили откатить
                  echo \"[HOOKS] Restoring $$TARGET_MK from backup...\"
                  cp -f \"$$BACKUP_MK\" \"$$TARGET_MK\"
                  
                  # Универсальная проверка восстановления (Smart Check)
                  if grep -E 'MKHASH|mkhash|md5sum' \"$$TARGET_MK\" >/dev/null 2>&1; then
                      echo -e \"$${GREEN}[HOOKS] ✓ Makefile restored: dynamic vermagic logic present$${NC}\"
                  else
                      # Если после восстановления всё ещё нет стандартных строк (очень старая версия или поврежденный бэкап)
                      echo -e \"$${YELLOW}[HOOKS] ! Makefile restored, but standard tools (MKHASH/mkhash) not explicitly found.$${NC}\"
                      echo \"[HOOKS] Assuming correct legacy state from backup.\"
                  fi
                  
                  # Удаляем бэкап
                  rm -f \"$$BACKUP_MK\"
                  if [ ! -f \"$$BACKUP_MK\" ]; then
                      echo \"[HOOKS] ✓ Backup file removed\"
                  fi
                  
              elif [ \"$$IS_PATCHED\" = \"true\" ]; then
                  echo \"[HOOKS] No backup. Attempting git restore...\"
                  git checkout -- \"$$TARGET_MK\" 2>/dev/null || true
                  
                  if grep -E 'MKHASH|mkhash|md5sum' \"$$TARGET_MK\" >/dev/null 2>&1; then
                      echo -e \"$${GREEN}[HOOKS] ✓ Git restore successful$${NC}\"
                  fi
              fi

              # 2. Удаление маркера vermagic
              if [ -f \"$$VERMAGIC_MARKER\" ]; then
                  rm -f \"$$VERMAGIC_MARKER\"
                  echo -e \"$${YELLOW}[HOOKS] ✓ Marker removed: next build will compute fresh hash$${NC}\"
              fi

              # Удаление маркера и очистка кэша ядра
              [ -f \"$$VERMAGIC_MARKER\" ] && rm -f \"$$VERMAGIC_MARKER\"
              echo \"[HOOKS] Performing deep kernel cache clean...\"
              make target/linux/clean > /dev/null 2>&1 || true
              # Удаление временных конфигов (Критично для 19.07/21.02)
              rm -rf tmp/.packageinfo tmp/.targetinfo tmp/.config-target.in 2>/dev/null
              # Удаление директорий ядра
              find build_dir/target-* -maxdepth 1 -type d -name \"linux-*\" -exec rm -rf {} + 2>/dev/null || true
              # Удаление штампов установки (чтобы форсировать пересчет)
              rm -rf staging_dir/target-*/pkginfo/kernel.default.install 2>/dev/null
              
              echo -e \"$${GREEN}[HOOKS] ✓ Kernel cache cleaned$${NC}\"
              # Сброс CCACHE при откате системы
              if [ -d \"/ccache\" ]; then
                  echo \"[HOOKS] Resetting CCACHE...\"
                  rm -rf /ccache/*
                  echo -e \"$${GREEN}[HOOKS] ✓ CCACHE reset$${NC}\"
              fi

              echo \"\"
              echo \"============================================================\"
              echo \"=== ROLLBACK COMPLETE ===\"
              echo \"=== System restored to original state\"
              echo \"============================================================\"
              echo \"\"
          fi
      fi

      # === ПОЛЬЗОВАТЕЛЬСКИЕ ИСХОДНИКИ (Makefile) ===
      if [ -d \"/input_packages\" ] && [ \"$$(ls -A /input_packages)\" ]; then
          echo \"[PKG] Injecting custom sources into package/ directory...\"
          cp -rf /input_packages/* package/
      fi

      # === 3. КОНФИГУРАЦИЯ (.config) ===
      echo \"[CONFIG] Checking configuration strategy...\"
      rm -f .config

      if [ -f \"/output/manual_config\" ]; then
          # Копируем ручной конфиг
          echo \"[CONFIG] !!! Manual configuration detected: manual_config !!!\"
          echo \"[CONFIG] Applying manual settings. SRC_EXTRA_CONFIG will be ignored.\"
          cp \"/output/manual_config\" .config
          # Всегда включаем CCACHE, так как это настройка среды сборки, а не прошивки
          echo \"CONFIG_CCACHE=y\" >> .config
      else
          echo \"[CONFIG] Generating standard configuration from profile...\"
          echo \"CONFIG_CCACHE=y\" >> .config
          # Базовая конфигурация Target
          echo \"CONFIG_TARGET_$$SRC_TARGET=y\" >> .config
          echo \"CONFIG_TARGET_$${SRC_TARGET}_$${SRC_SUBTARGET}=y\" >> .config
          echo \"CONFIG_TARGET_$${SRC_TARGET}_$${SRC_SUBTARGET}_DEVICE_$$TARGET_PROFILE=y\" >> .config
          
          # Добавляем пользовательские пакеты из SRC_PACKAGES
          for pkg in $$SRC_PACKAGES; do
              if [[ \"$$pkg\" == -* ]]; then
                  clean_pkg=\"$${pkg#-}\"
                  echo \"# CONFIG_PACKAGE_$$clean_pkg is not set\" >> .config
              else
                  echo \"CONFIG_PACKAGE_$$pkg=y\" >> .config
              fi
          done
          
          # Включение LuCI по умолчанию
          if ! grep -q \"CONFIG_PACKAGE_luci=y\" .config; then
              echo \"CONFIG_PACKAGE_luci=y\" >> .config
          fi
          
          # Размеры разделов
          [ -n \"$$ROOTFS_SIZE\" ] && echo \"CONFIG_TARGET_ROOTFS_PARTSIZE=$$ROOTFS_SIZE\" >> .config
          [ -n \"$$KERNEL_SIZE\" ] && echo \"CONFIG_TARGET_KERNEL_PARTSIZE=$$KERNEL_SIZE\" >> .config

          # Дополнительные опции из профиля
          if [ -n \"$$SRC_EXTRA_CONFIG\" ]; then
              # Обрабатываем переменную как список строк
              echo \"[CONFIG] Applying extra configuration options...\"
              for opt in $$SRC_EXTRA_CONFIG; do
                  echo \"$$opt\" >> .config
              done
          fi
      fi

      echo \"[DEBUG] Final .config seed settings:\"
      echo \"----------------------------------------\"      
      grep -v \"^#\" .config || true
      echo \"----------------------------------------\"      
     
      # Обработка зависимостей через defconfig
      make defconfig
      
      # === 4. ПОЛЬЗОВАТЕЛЬСКИЕ ФАЙЛЫ (Overlay) ===
      if [ -d \"/overlay_files\" ] && [ \"$$(ls -A /overlay_files)\" ]; then
          echo \"[FILES] Copying overlay files to build directory...\"
          mkdir -p files
          cp -r /overlay_files/* files/
          rm -f files/hooks.sh
      fi
      
      # === 5. ЗАГРУЗКА ИСХОДНИКОВ ===
      echo \"[DOWNLOAD] Downloading sources...\"
      mkdir -p dl
      make download || (echo \"[ERROR] Download failed! Retrying with verbose logs...\" && make download V=s && exit 1)
      
      # Определение количества потоков сборки
      # === 6. СБОРКА ===
      SYS_CORES=$$(nproc)
      # По умолчанию берем все ядра
      BUILD_JOBS=$$SYS_CORES

      if [ -n \"$$SRC_CORES\" ]; then
          if [[ \"$$SRC_CORES\" == \"safe\" || \"$$SRC_CORES\" == \"auto\" ]]; then
              echo \"[BUILD] Safe mode: Using $$((SYS_CORES - 1)) cores.\"
              BUILD_JOBS=$$((SYS_CORES - 1))
          # Если указано конкретное число
          elif [[ \"$$SRC_CORES\" =~ ^[0-9]+$$ ]]; then
              BUILD_JOBS=$$SRC_CORES
          fi
      fi

      # Защита от дурака: минимум 1 ядро
      [ \"$$BUILD_JOBS\" -lt 1 ] && BUILD_JOBS=1
      
      echo \"[BUILD] Starting compilation...\"
      echo \"        CPU Cores: $$SYS_CORES\"
      echo \"        Parallel Jobs: -j$$BUILD_JOBS\"

      make -j$$BUILD_JOBS || (echo \"[ERROR] Multicore build failed. Falling back to single core...\" && make -j1 V=s)
      
      # === 7. СОХРАНЕНИЕ АРТЕФАКТОВ ===
      echo \"[SAVE] Saving artifacts...\"
      TARGET_DIR=\"/output/$$TIMESTAMP\"
      mkdir -p \"$$TARGET_DIR\"
      
      # Ищем файлы рекурсивно внутри bin/targets/ARCH, игнорируя папку packages
      find bin/targets/$$SRC_TARGET -type f -not -path \"*/packages/*\" -exec cp {} \"$$TARGET_DIR/\" \\;
      # Сохраняем итоговый конфиг для справки
      cp .config \"$$TARGET_DIR/build.config\"
      
      END_TIME=$$(date +%s)
      ELAPSED=$$((END_TIME - START_TIME))
      
      echo \"\"
      echo \"============================================================\"
      echo \"=== Build $$PROFILE_NAME completed in $${ELAPSED}s.\"
      echo \"=== Artifacts: firmware_output/sourcebuilder/$$PROFILE_ID/$$TIMESTAMP\"
      echo \"============================================================\"
      EOF
      
      chmod +x /tmp/build_script.sh
      chown build:build /tmp/build_script.sh
      
      # Запуск скрипта от лица пользователя build
      echo '[EXEC] Switching to user build...'
      sudo -E -u build bash /tmp/build_script.sh
      "

  builder-src-oldwrt:
    build:
      context: ..
      dockerfile: system/src.dockerfile.legacy
    user: "root"
    environment:
      - CONF_FILE=${SELECTED_CONF}
      - CCACHE_DIR=/ccache
    volumes:
      - src-workdir:/home/build/openwrt
      - src-dl-cache:/home/build/openwrt/dl
      - src-ccache:/ccache
      - ../profiles:/profiles
      - ../${HOST_PKGS_DIR}:/input_packages
      - ../${HOST_FILES_DIR}:/overlay_files
      - ../${HOST_OUTPUT_DIR}:/output
      - ./openssl.cnf:/openssl.cnf
    command: *src_build_script

volumes:
  src-dl-cache:
  src-workdir:
  src-ccache: