# file: system\docker-compose.yaml V1.41
services:
  builder-openwrt:
    build:
      context: ..
      dockerfile: system/dockerfile
    environment:
      - CONF_FILE=${SELECTED_CONF}
    volumes:
      - imagebuilder-cache:/cache
      - ipk-cache:/builder_workspace/dl
      - ../custom_packages:/input_packages
      - ../${HOST_FILES_DIR}:/overlay_files
      - ../${HOST_OUTPUT_DIR}:/output
      - ../profiles:/profiles
      - ./openssl.cnf:/openssl.cnf
    command: &build_script |
      /bin/bash -c "
      set -e
      if [ ! -f \"/profiles/$$CONF_FILE\" ]; then
        echo \"FATAL: Profile /profiles/$$CONF_FILE not found!\"
        exit 1
      fi

      # === 0. ПОВЫШЕНИЕ СТАБИЛЬНОСТИ СЕТИ (FIX FRAGILITY) ===
      # Создаем глобальный конфиг wgetrc, который подхватит OPKG внутри make image
      echo \"tries = 5\" > ~/.wgetrc
      echo \"timeout = 20\" >> ~/.wgetrc
      echo \"retry_connrefused = on\" >> ~/.wgetrc
      echo \"waitretry = 2\" >> ~/.wgetrc
      # Иногда бывают проблемы с SSL на старых образах, опционально:
      # echo \"check_certificate = off\" >> ~/.wgetrc

      # === 1. ПОДГОТОВКА КОНФИГА ===
      echo \"[INIT] Normalizing config...\"
      # Используем двойные слэши \\xEF, чтобы YAML и Bash передали их в sed корректно
      cat \"/profiles/$$CONF_FILE\" | sed '1s/^\\xEF\\xBB\\xBF//' | tr -d '\\r' > /tmp/clean_config.env
      source /tmp/clean_config.env

      # Проверка на ошибки парсинга
      if [ -z \"$$IMAGEBUILDER_URL\" ]; then
         echo \"[ERROR] IMAGEBUILDER_URL is empty! Config was not parsed correctly.\"
         exit 1
      fi

      # === ЗАСЕКАЕМ ВРЕМЯ ===
      START_TIME=$$(date +%s)
      TIMESTAMP=$$(TZ='UTC-3' date +%d%m%y-%H%M%S)

      # --- 2. СКАЧИВАНИЕ SDK (АТОМАРНОЕ) ---
      ARCHIVE_NAME=$$(basename \"$$IMAGEBUILDER_URL\")
      CACHE_FILE=\"/cache/$$ARCHIVE_NAME\"
      TEMP_CACHE_FILE=\"/cache/$$ARCHIVE_NAME.tmp\"

      # Функция ожидания, если другой контейнер уже качает файл
      wait_for_download() {
          echo \"[CACHE BUSY] Another build is downloading SDK. Waiting...\"
          while [ -f \"$$TEMP_CACHE_FILE\" ]; do
              sleep 5
          done
          if [ ! -f \"$$CACHE_FILE\" ]; then return 1; fi
      }

      if [ ! -f \"$$CACHE_FILE\" ]; then        
          if [ -f \"$$TEMP_CACHE_FILE\" ]; then
              wait_for_download || echo \"[CACHE RETRY] Neighbor failed, downloading...\"
          fi
          
          if [ ! -f \"$$CACHE_FILE\" ]; then
              echo \"[CACHE MISS] Downloading $$ARCHIVE_NAME...\"
              # Используем dot:giga для чистоты логов + параметры надежности
              wget --progress=dot:giga --tries=5 --timeout=20 --retry-connrefused -O \"$$TEMP_CACHE_FILE\" \"$$IMAGEBUILDER_URL\"
              mv \"$$TEMP_CACHE_FILE\" \"$$CACHE_FILE\"
          else
             echo \"[CACHE HIT] File appeared after wait: $$ARCHIVE_NAME\"
          fi
      else
        echo \"[CACHE HIT] Using $$ARCHIVE_NAME\"
      fi

      echo \"Extracting...\"
      if echo \"$$IMAGEBUILDER_URL\" | grep -q '.zst$$'; then
          tar -I zstd -xf \"$$CACHE_FILE\" --strip-components=1 2>/dev/null || true
      else
          tar -xJf \"$$CACHE_FILE\" --strip-components=1 2>/dev/null || true
      fi

      # --- 3. ПОДГОТОВКА ОКРУЖЕНИЯ ---
      if [ -f /openssl.cnf ]; then
         echo \"Applying OpenSSL Fix...\"
         mkdir -p /builder/shared-workdir/build/staging_dir/host/etc/ssl
         cp /openssl.cnf /builder/shared-workdir/build/staging_dir/host/etc/ssl/openssl.cnf
      fi

      # Копируем кастомные IPK
      [ -d /input_packages ] && cp /input_packages/*.ipk packages/ 2>/dev/null || true
      #fix для древних сборок
      export SOURCE_DATE_EPOCH=$$(date +%s)

      # === ИЗМЕНЕНИЕ РАЗМЕРА РАЗДЕЛОВ ===
      # RootFS Size
      if [ -n \"$$ROOTFS_SIZE\" ]; then
        echo \"[CONFIG] Setting RootFS size to $$ROOTFS_SIZE MB...\"
        touch .config
        sed -i '/CONFIG_TARGET_ROOTFS_PARTSIZE/d' .config
        echo \"CONFIG_TARGET_ROOTFS_PARTSIZE=$$ROOTFS_SIZE\" >> .config
      else
        echo \"[CONFIG] Using default RootFS size\"
      fi

      # Kernel Size
      if [ -n \"$$KERNEL_SIZE\" ]; then
        echo \"[CONFIG] Setting Kernel size to $$KERNEL_SIZE MB...\"
        touch .config
        sed -i '/CONFIG_TARGET_KERNEL_PARTSIZE/d' .config
        echo \"CONFIG_TARGET_KERNEL_PARTSIZE=$$KERNEL_SIZE\" >> .config
      else
        echo \"[CONFIG] Using default KernelFS size\"
      fi

      # --- 4. ЗАГРУЗКА КЛЮЧЕЙ И РЕПОЗИТОРИЕВ ---
      if [ -n \"$$CUSTOM_KEYS\" ]; then
         echo \"[REPO] Downloading custom keys...\"
         for key_url in $$CUSTOM_KEYS; do
             echo \"   -> $$key_url\"
             wget -q --tries=5 --timeout=15 --retry-connrefused \"$$key_url\" -P keys/ || echo \"[WARN] Failed to download key: $$key_url\"
             
             key_filename=$$(basename \"$$key_url\")
             key_id=$${key_filename%.*}
             if [ -f \"keys/$$key_filename\" ] && [ \"$$key_filename\" != \"$$key_id\" ]; then
                 cp \"keys/$$key_filename\" \"keys/$$key_id\"
             fi
         done
      fi
      
      if [ -n \"$$CUSTOM_REPOS\" ]; then
         echo \"[REPO] Adding custom repositories...\"
         sed -i '/fantastic_/d' repositories.conf
         clean_repos=$$(echo "$$CUSTOM_REPOS" | sed 's# src/gz#\\nsrc/gz#g')
         echo \"$$clean_repos\" >> repositories.conf
         echo \"--- Repositories list: ---\"
         cat repositories.conf
         echo \"--------------------------\"
      fi
      # === ПОДГОТОВКА OVERLAY (Удаление hooks.sh) ===
      echo \"[OVERLAY] Preparing custom files...\"

      # --- 5. OVERLAY ---
      mkdir -p /tmp/clean_overlay
      
      # 2. Копируем туда файлы (флаг -a сохраняет права доступа, /. копирует и скрытые файлы)
      if [ -d \"/overlay_files\" ]; then
          cp -a /overlay_files/. /tmp/clean_overlay/ 2>/dev/null || true
      fi

      # 3. БЕЗОПАСНО удаляем hooks.sh и прочий мусор из копии
      if [ -f \"/tmp/clean_overlay/hooks.sh\" ]; then
          echo \"[OVERLAY] Removing hooks.sh from firmware build...\"
          rm -f \"/tmp/clean_overlay/hooks.sh\"
      fi
      # Можно также удалить README или другие служебные файлы
      rm -f \"/tmp/clean_overlay/README.md\"      
      # --- 3. СБОРКА ---
      # --- 6. ЗАПУСК СБОРКИ (С ПОВТОРОМ ПРИ СБОЕ) ---
      echo \"Starting make image for $$TARGET_PROFILE...\"      
      MAKE_ARGS=\"PROFILE=\\\"$$TARGET_PROFILE\\\" FILES=\\\"/overlay_files\\\" PACKAGES=\\\"$$PKGS\\\"\"
      
      if [ -n \"$$EXTRA_IMAGE_NAME\" ]; then MAKE_ARGS=\"$$MAKE_ARGS EXTRA_IMAGE_NAME=\\\"$$EXTRA_IMAGE_NAME\\\"\"; fi
      if [ -n \"$$DISABLED_SERVICES\" ]; then MAKE_ARGS=\"$$MAKE_ARGS DISABLED_SERVICES=\\\"$$DISABLED_SERVICES\\\"\"; fi
      
      # === ЦИКЛ RETRY ===
      MAX_RETRIES=3
      COUNT=1
      SUCCESS=0
      
      while [ $$COUNT -le $$MAX_RETRIES ]; do
          echo \"--------------------------------------------------\"
          echo \"[BUILD] Attempt $$COUNT of $$MAX_RETRIES...\"
          echo \"--------------------------------------------------\"
          
          # Запускаем make. Если успешно - выходим из цикла (break)
          if eval make image $$MAKE_ARGS; then
              SUCCESS=1
              break
          else
              echo \"[WARN] Build failed!\"
              # Проверяем, не была ли это ошибка сети (код 255 или 2 часто бывает при сбоях opkg)
              echo \"[RETRY] Cleaning temporary build files and retrying in 5 seconds...\"
              sleep 5
              # Опционально: можно сделать make clean, но для ImageBuilder это не обязательно
              COUNT=$$((COUNT+1))
          fi
      done
      
      if [ $$SUCCESS -eq 0 ]; then
          echo \"[FATAL] Build failed after $$MAX_RETRIES attempts.\"
          exit 1
      fi

      # --- 7. СОХРАНЕНИЕ ---
      echo \"Saving artifacts...\"
      TARGET_DIR=\"/output/$$TIMESTAMP\"
      mkdir -p \"$$TARGET_DIR\"
      find bin/targets -type f -not -path \"*/packages/*\" | while read f; do
          cp \"$$f\" \"$$TARGET_DIR/\"
      done

      # --- 5. РАСЧЕТ ВРЕМЕНИ ---
      END_TIME=$$(date +%s)
      ELAPSED=$$((END_TIME - START_TIME))
      echo \"\"
      echo \"============================================================\"
      echo \"=== Сборка $$PROFILE_NAME завершена за $${ELAPSED}с.\"
      echo \"=== Файлы сохранены в: firmware_output/imagebuilder/$$PROFILE_NAME/$$TIMESTAMP\"
      echo \"============================================================\"
      "

  builder-oldwrt:
    build:
      context: ..
      dockerfile: system/dockerfile.legacy
    environment:
      - CONF_FILE=${SELECTED_CONF}
    volumes:
      - imagebuilder-cache:/cache
      - ipk-cache:/builder_workspace/dl
      - ../custom_packages:/input_packages
      - ../${HOST_FILES_DIR}:/overlay_files
      - ../${HOST_OUTPUT_DIR}:/output
      - ../profiles:/profiles
      - ./openssl.cnf:/openssl.cnf
    command: *build_script

volumes:
  imagebuilder-cache:
  ipk-cache:
